-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Software specification and verification tool based on graph rewriting.
--   
--   Software specification and verification tool based on graph rewriting.
@package verigraph
@version 1.0

module Abstract.Relation

-- | Datatype for endorelations on a
data Relation a

-- | An empty relation, with domain and codomain specified.
empty :: Ord a => [a] -> [a] -> Relation a

-- | Compose <tt>r1</tt> and <tt>r2</tt>.
compose :: (Ord a) => Relation a -> Relation a -> Relation a

-- | The identity relation on <tt>dom</tt>.
id :: Ord a => [a] -> Relation a

-- | The inverse relation.
inverseRelation :: (Ord a) => Relation a -> Relation a

-- | Add a mapping between <tt>x</tt> and <tt>y</tt> to the relation. If
--   <tt>x</tt> already exists, <tt>y</tt> is joined to the corresponding
--   elements.
updateRelation :: Ord a => a -> a -> Relation a -> Relation a

-- | Remove an element from the domain of the relation
removeFromDomain :: Ord a => a -> Relation a -> Relation a

-- | Remove an element from the codomain of the relation
removeFromCodomain :: Ord a => a -> Relation a -> Relation a

-- | Insert an element on the codomain of the relation
insertOnCodomain :: Ord a => a -> Relation a -> Relation a

-- | Return a list of all elements that <tt>x</tt> gets mapped into.
apply :: (Ord a) => Relation a -> a -> [a]
domain :: Relation a -> [a]
codomain :: Relation a -> [a]

-- | Return a list of all elements in the image of the relation.
image :: (Eq a) => Relation a -> [a]
mapping :: Relation a -> Map a [a]

-- | Return the elements in the domain which are not in the image of the
--   relation (orphans)
orphans :: (Eq a) => Relation a -> [a]

-- | Test if <tt>r</tt> is functional.
isFunctional :: Relation a -> Bool

-- | Test if <tt>r</tt> is injective.
isInjective :: (Ord a) => Relation a -> Bool

-- | Test if <tt>r</tt> is injective out of domain <tt>list</tt>
isPartialInjective :: Ord a => [a] -> Relation a -> Bool

-- | Test if <tt>r</tt> is surjective.
isSurjective :: (Ord a) => Relation a -> Bool

-- | Test if <tt>r</tt> is total.
isTotal :: (Ord a) => Relation a -> Bool
instance (GHC.Classes.Ord a, GHC.Read.Read a) => GHC.Read.Read (Abstract.Relation.Relation a)
instance GHC.Show.Show a => GHC.Show.Show (Abstract.Relation.Relation a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Abstract.Relation.Relation a)
instance (GHC.Classes.Eq a, GHC.Classes.Ord a) => GHC.Classes.Eq (Abstract.Relation.Relation a)


module Logic.Model

-- | A Kripke structure is composed of a list of states and a list of
--   transitions between such states. States are labeled with the atomic
--   propositions that hold in it.
--   
--   This particular kind of labeled transition system may be used as a
--   model for temporal logics. In particular, it may be used for model
--   checking.
--   
--   This structure is polymorphic on the type of atomic propositions.
data KripkeStructure a
KripkeStructure :: [State a] -> [Transition a] -> KripkeStructure a

-- | List of labeled states of the Kripke structure
[states] :: KripkeStructure a -> [State a]

-- | List of transitions of the Kripke structure
[transitions] :: KripkeStructure a -> [Transition a]

-- | A state contains its unique identifier and a list of atomic
--   propositions that hold in it.
data State a
State :: Int -> [a] -> State a

-- | A transition contains the identifiers of the source and target states.
data Transition a
Transition :: Int -> Int -> Int -> [a] -> Transition a
[transitionId] :: Transition a -> Int
[source] :: Transition a -> Int
[target] :: Transition a -> Int
[transitionPayload] :: Transition a -> [a]

-- | List of all state IDs from a given Kripke structure
stateIds :: KripkeStructure a -> [Int]

-- | Finds the state with given ID in the given Kripke structure
lookupState :: Int -> KripkeStructure a -> Maybe (State a)

-- | Gets the state with given ID in the given Kripke structure, <b>fails
--   if there is none</b>.
getState :: Int -> KripkeStructure a -> State a

-- | List of all transition IDs on a given Kripke structure
transitionIds :: KripkeStructure a -> [Int]

-- | Finds the transition with given ID in the given Kripke structure.
lookupTransition :: Int -> KripkeStructure a -> Maybe (Transition a)

-- | Gets the transition with given ID in the given Kripke structure,
--   <b>fails if there is none</b>.
getTransition :: Int -> KripkeStructure a -> Transition a

-- | Obtains the IDs of the states that are reachable by a single
--   transition from the state with given ID.
nextStates :: KripkeStructure a -> Int -> [Int]

-- | Tests if the second given state is reachable from the first by a
--   single transition
precedes :: KripkeStructure a -> Int -> Int -> Bool

-- | Obtains the IDs of the states from which the given state is reachable
--   by a single transition.
prevStates :: KripkeStructure a -> Int -> [Int]

-- | Tests if the first given state is reachable from the second by a
--   single transition
follows :: KripkeStructure a -> Int -> Int -> Bool

-- | Type class for elements that have a numeric identifier and a list of
--   associated values.
class Element e where type Payload e :: * where {
    type family Payload e :: *;
}

-- | Obtain the numeric identifier of an element.
elementId :: Element e => e -> Int

-- | Obtain the associated values of an element.
values :: Element e => e -> [Payload e]

-- | Given a list of elements, find the element with the given identifier.
findById :: Element a => Int -> [a] -> Maybe a
instance GHC.Classes.Eq a => GHC.Classes.Eq (Logic.Model.KripkeStructure a)
instance GHC.Read.Read a => GHC.Read.Read (Logic.Model.KripkeStructure a)
instance GHC.Show.Show a => GHC.Show.Show (Logic.Model.KripkeStructure a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Logic.Model.Transition a)
instance GHC.Read.Read a => GHC.Read.Read (Logic.Model.Transition a)
instance GHC.Show.Show a => GHC.Show.Show (Logic.Model.Transition a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Logic.Model.State a)
instance GHC.Read.Read a => GHC.Read.Read (Logic.Model.State a)
instance GHC.Show.Show a => GHC.Show.Show (Logic.Model.State a)
instance Logic.Model.Element (Logic.Model.State a)
instance Logic.Model.Element (Logic.Model.Transition a)


module Logic.Ctl

-- | CTL expressions
data Expr
Literal :: Bool -> Expr
Atom :: String -> Expr
Not :: Expr -> Expr
And :: Expr -> Expr -> Expr
Or :: Expr -> Expr -> Expr
Implies :: Expr -> Expr -> Expr
Equiv :: Expr -> Expr -> Expr
Temporal :: (PathQuantified Expr) -> Expr

-- | Path-quantified CTL expressions
data PathQuantified e
A :: (StateQuantified e) -> PathQuantified e
E :: (StateQuantified e) -> PathQuantified e

-- | State-quantified CTL expressions
data StateQuantified e
X :: e -> StateQuantified e
G :: e -> StateQuantified e
F :: e -> StateQuantified e
U :: e -> e -> StateQuantified e

-- | Parse a CTL expressions from the given string.
--   
--   The first parameter will be used to identify the source of the text in
--   error messages.
--   
--   This parser is compatible with the pretty printer of expressions, that
--   is, pretty printed expressions will be parseable by this (unless they
--   contain illegal identifiers for atomic propositions).
parseExpr :: SourceName -> String -> Either ParseError Expr

-- | Check if the given expression holds in the given state of the Kripke
--   structure.
check :: KripkeStructure String -> Expr -> Int -> Bool

-- | Obtain all states that satisfy the given CTL expression.
satisfyExpr :: KripkeStructure String -> Expr -> [State String]

-- | Obtain the identifiers of all states that satisfy the given CTL
--   expression.
satisfyExpr' :: KripkeStructure String -> Expr -> [Int]

module Abstract.Valid

-- | Type class for types that admit "malformed" values, and must thus be
--   checked.
--   
--   Although implementing the <a>isValid</a> method is sufficient, it will
--   result in poor error messages. Therefore, implementing the
--   <a>validate</a> method is recommended.
class Valid a where isValid x = case validate x of { IsValid -> True IsInvalid _ -> False } validate x = if isValid x then IsValid else IsInvalid ["<invalid value>"]

-- | Checks if the given value is well-formed
isValid :: Valid a => a -> Bool

-- | Checks if the given value is well-formed, providing an explanation of
--   any errors encountered.
validate :: Valid a => a -> ValidationResult

-- | Result of validating some value
data ValidationResult

-- | Return <a>IsValid</a> if the given boolean is true, otherwise return
--   <a>IsInvalid</a> with the given error message.
ensure :: Bool -> String -> ValidationResult

-- | Prepends the indication of context to any error messages produced by
--   the validation result.
withContext :: String -> ValidationResult -> ValidationResult

-- | Obtains the error messages produced by validation, or <a>Nothing</a>
--   if no error was found
errorMessages :: ValidationResult -> Maybe String

-- | Validates a list of named values, modifying their names with the given
--   function.
validateNamed :: Valid a => (name -> String) -> [(name, a)] -> ValidationResult

-- | If the given validation detected some error, prints the error out and
--   exits with failure.
ensureValid :: ValidationResult -> IO ()
instance GHC.Base.Monoid Abstract.Valid.ValidationResult

module Graph.Graph
data Edge a
newtype EdgeId
EdgeId :: Int -> EdgeId
data Node a
newtype NodeId
NodeId :: Int -> NodeId
data Graph a b
Graph :: [(NodeId, Node a)] -> [(EdgeId, Edge b)] -> Graph a b
[nodeMap] :: Graph a b -> [(NodeId, Node a)]
[edgeMap] :: Graph a b -> [(EdgeId, Edge b)]

-- | Create an empty Graph.
empty :: Graph a b

-- | Build a Graph
build :: [Int] -> [(Int, Int, Int)] -> Graph a b

-- | Insert an edge <tt>e</tt> from <tt>src</tt> to <tt>tgt</tt> in graph
--   <tt>g</tt>, without payload.
insertEdge :: EdgeId -> NodeId -> NodeId -> Graph a b -> Graph a b

-- | Insert a node <tt>n</tt> in a graph <tt>g</tt>, without payload.
insertNode :: NodeId -> Graph a b -> Graph a b

-- | Insert an edge <tt>e</tt> from <tt>src</tt> to <tt>tgt</tt> in graph
--   <tt>g</tt> with payload <tt>p</tt>.
insertEdgeWithPayload :: EdgeId -> NodeId -> NodeId -> b -> Graph a b -> Graph a b

-- | Insert a node <tt>n</tt> in a graph <tt>g</tt> with payload
--   <tt>p</tt>.
insertNodeWithPayload :: NodeId -> a -> Graph a b -> Graph a b

-- | Remove edge <tt>e</tt> from <tt>g</tt>.
removeEdge :: EdgeId -> Graph a b -> Graph a b

-- | If <tt>n</tt> exists in <tt>g</tt>, and there are no incident edges on
--   it, remove it. Return <tt>g</tt> otherwise.
removeNode :: NodeId -> Graph a b -> Graph a b

-- | Update <tt>e</tt>'s payload, applying <tt>f</tt> on it.
updateEdgePayload :: EdgeId -> Graph a b -> (b -> b) -> Graph a b

-- | Update <tt>n</tt>'s payload, applying <tt>f</tt> on it.
updateNodePayload :: NodeId -> Graph a b -> (a -> a) -> Graph a b

-- | Return a list of all edge id's from from <tt>g</tt>.
edges :: Graph a b -> [EdgeId]

-- | Return a list of all node id's from from <tt>g</tt>.
nodes :: Graph a b -> [NodeId]

-- | Return a list of all edges with <tt>n</tt> as a source node.
outgoingEdges :: Graph a b -> NodeId -> [EdgeId]

-- | Return a list of all edges with <tt>n</tt> as a target node.
incomingEdges :: Graph a b -> NodeId -> [EdgeId]

-- | Return a list of all edge id's, together with their payloads.
edgesWithPayload :: Graph a b -> [(EdgeId, Maybe b)]

-- | Return a list of all incident edges on <tt>n</tt>.
incidentEdges :: Graph a b -> NodeId -> [EdgeId]

-- | Return a list of all neighbour nodes from <tt>n</tt>.
neighbourNodes :: Graph a b -> NodeId -> [NodeId]

-- | Return a pair containing <tt>e</tt>'s source and target nodes.
nodesOf :: Graph a b -> EdgeId -> Maybe (NodeId, NodeId)

-- | Return a list of all nodes that are target of any edge going out from
--   <tt>n</tt>.
targetedNodes :: Graph a b -> NodeId -> [NodeId]

-- | Return a list of all nodes that are source of any edge going into
--   <tt>n</tt>.
sourceNodes :: Graph a b -> NodeId -> [NodeId]

-- | Return a list of all node id's, together with their payloads.
nodesWithPayload :: Graph a b -> [(NodeId, Maybe a)]

-- | Test whether a graph is empty.
null :: Graph a b -> Bool

-- | Return <tt>n</tt>'s payload.
nodePayload :: Graph a b -> NodeId -> Maybe a

-- | Return <tt>e</tt>'s payload.
edgePayload :: Graph a b -> EdgeId -> Maybe b

-- | Return <tt>e</tt>'s source.
sourceOf :: Graph a b -> EdgeId -> Maybe NodeId

-- | Return <tt>e</tt>'s source or error in the case of undefined
sourceOfUnsafe :: Graph a b -> EdgeId -> NodeId

-- | Return <tt>e</tt>'s target.
targetOf :: Graph a b -> EdgeId -> Maybe NodeId

-- | Return <tt>e</tt>'s target or error in the case of undefined
targetOfUnsafe :: Graph a b -> EdgeId -> NodeId
extractSource :: Graph a b -> EdgeId -> NodeId
extractTarget :: Graph a b -> EdgeId -> NodeId

-- | Test if <tt>e</tt> is an edge from graph <tt>g</tt>.
isEdgeOf :: Graph a b -> EdgeId -> Bool

-- | Test if <tt>n</tt> is a node from graph <tt>g</tt>.
isNodeOf :: Graph a b -> NodeId -> Bool

-- | Test if <tt>n1</tt> and <tt>n2</tt> are adjacent.
isAdjacentTo :: Graph a b -> NodeId -> NodeId -> Bool

-- | Test if <tt>n</tt> is connected to edge <tt>e</tt>.
isIncidentTo :: Graph a b -> NodeId -> EdgeId -> Bool

-- | Infinite list of new node instances of a graph
newNodes :: Graph a b -> [NodeId]

-- | Infinite list of new edge instances of a graph
newEdges :: Graph a b -> [EdgeId]
instance (GHC.Read.Read a, GHC.Read.Read b) => GHC.Read.Read (Graph.Graph.Graph a b)
instance GHC.Read.Read Graph.Graph.EdgeId
instance GHC.Classes.Ord Graph.Graph.EdgeId
instance GHC.Classes.Eq Graph.Graph.EdgeId
instance GHC.Read.Read a => GHC.Read.Read (Graph.Graph.Edge a)
instance GHC.Show.Show a => GHC.Show.Show (Graph.Graph.Edge a)
instance GHC.Read.Read Graph.Graph.NodeId
instance GHC.Classes.Ord Graph.Graph.NodeId
instance GHC.Classes.Eq Graph.Graph.NodeId
instance GHC.Read.Read a => GHC.Read.Read (Graph.Graph.Node a)
instance GHC.Show.Show a => GHC.Show.Show (Graph.Graph.Node a)
instance GHC.Classes.Eq (Graph.Graph.Node a)
instance GHC.Classes.Eq (Graph.Graph.Edge a)
instance GHC.Classes.Eq (Graph.Graph.Graph a b)
instance GHC.Show.Show (Graph.Graph.Graph a b)
instance GHC.Show.Show Graph.Graph.NodeId
instance GHC.Show.Show Graph.Graph.EdgeId
instance GHC.Num.Num Graph.Graph.NodeId
instance GHC.Enum.Enum Graph.Graph.NodeId
instance GHC.Num.Num Graph.Graph.EdgeId
instance GHC.Enum.Enum Graph.Graph.EdgeId
instance Abstract.Valid.Valid (Graph.Graph.Graph a b)

module Abstract.Morphism
class (Eq m) => Morphism m where type Obj m :: * where {
    type family Obj m :: *;
}

-- | Apply the first argument first (compose f g = g . f)
compose :: Morphism m => m -> m -> m
domain :: Morphism m => m -> Obj m
codomain :: Morphism m => m -> Obj m
id :: Morphism m => Obj m -> m
isMonomorphism :: Morphism m => m -> Bool
isEpimorphism :: Morphism m => m -> Bool
isIsomorphism :: Morphism m => m -> Bool

-- | Enum for the types of morphisms that can be used / found
data MorphismType
GenericMorphism :: MorphismType
Monomorphism :: MorphismType
Epimorphism :: MorphismType
Isomorphism :: MorphismType
class Morphism m => FindMorphism m where findMonomorphisms = findMorphisms Monomorphism findEpimorphisms = findMorphisms Epimorphism findIsomorphisms = findMorphisms Isomorphism findAllMorphisms = findMorphisms GenericMorphism

-- | Given a type <b><i>t</i></b> of <tt>MorphismType</tt> and two objects
--   <b><i>A</i></b> and <b><i>B</i></b>, it finds all the matches m : A
--   -&gt; B in which m is of the type t
findMorphisms :: FindMorphism m => MorphismType -> Obj m -> Obj m -> [m]

-- | Given two objects A and B, finds all monomorphisms from A to B
findMonomorphisms :: FindMorphism m => Obj m -> Obj m -> [m]

-- | Given two objects A and B, finds all epimorphisms from A to B
findEpimorphisms :: FindMorphism m => Obj m -> Obj m -> [m]

-- | Given two objects A and B, finds all isomorphisms from A to B
findIsomorphisms :: FindMorphism m => Obj m -> Obj m -> [m]

-- | Given two objects A and B, finds all morphisms from A to B
findAllMorphisms :: FindMorphism m => Obj m -> Obj m -> [m]

-- | Given a NAC <i>n : L -&gt; N </i> and a match <i>m : L -&gt; G</i>,
--   finds the morphisms from <i>N</i> to <i>G</i> that are injective out
--   of the image of <i>n</i>
partialInjectiveMatches :: FindMorphism m => m -> m -> [m]
instance GHC.Enum.Enum Abstract.Morphism.MorphismType
instance GHC.Show.Show Abstract.Morphism.MorphismType

module Graph.GraphMorphism
data GraphMorphism a b

-- | An empty morphism between two graphs.
empty :: Graph a b -> Graph a b -> GraphMorphism a b

-- | Construct a graph morphism
buildGraphMorphism :: Graph a b -> Graph a b -> [(Int, Int)] -> [(Int, Int)] -> GraphMorphism a b

-- | The inverse graph morphism.
invertGraphMorphism :: GraphMorphism a b -> GraphMorphism a b

-- | Set a new codomain.
updateCodomain :: Graph a b -> GraphMorphism a b -> GraphMorphism a b

-- | Set a new domain.
updateDomain :: Graph a b -> GraphMorphism a b -> GraphMorphism a b

-- | Add a mapping between both nodes into the morphism. If <tt>ln</tt> is
--   already mapped, or neither nodes are in their respective graphs,
--   return the original morphism.
updateNodes :: NodeId -> NodeId -> GraphMorphism a b -> GraphMorphism a b

-- | Inserts nodes in a graph morphism, if the nodes do not exist, they are
--   created
updateNodeRelation :: NodeId -> NodeId -> GraphMorphism a b -> GraphMorphism a b

-- | Modifies a graph morphism, mapping edge e1 to edge e2. It assumes both
--   edges already exist.
updateEdgeRelation :: EdgeId -> EdgeId -> GraphMorphism a b -> GraphMorphism a b

-- | Add a mapping between both edges into the morphism. If <tt>le</tt> is
--   already mapped, or neither edges are in their respective graphs,
--   return the original morphism.
updateEdges :: EdgeId -> EdgeId -> GraphMorphism a b -> GraphMorphism a b

-- | Remove an edge from the domain of the morphism
removeEdgeFromDomain :: EdgeId -> GraphMorphism a b -> GraphMorphism a b

-- | Remove an edge from the codomain of the morphism
removeEdgeFromCodomain :: EdgeId -> GraphMorphism a b -> GraphMorphism a b

-- | Remove a node from the domain of the morphism
--   
--   TODO: what happens if there were edges incident to the node?
removeNodeFromDomain :: NodeId -> GraphMorphism a b -> GraphMorphism a b

-- | Remove a node from the codomain of the morphism
--   
--   TODO: what happens if there were edges incident to the node?
removeNodeFromCodomain :: NodeId -> GraphMorphism a b -> GraphMorphism a b

-- | This function adds an edge e1 (with source s1 and target t1) to the
--   domain of the morphism, and associate it to e2 It assumes s1, t1, e2
--   already exist, and that e1 does not exist.
createEdgeOnDomain :: EdgeId -> NodeId -> NodeId -> EdgeId -> GraphMorphism a b -> GraphMorphism a b

-- | This function adds an edge e2 (with source s2 and target t2) to the
--   codomain of the morphism. It assumes that s2,t2 exist, and that e2
--   does not exist
createEdgeOnCodomain :: EdgeId -> NodeId -> NodeId -> GraphMorphism a b -> GraphMorphism a b

-- | This function adds an edge e1 (with source s1 and target t1) to the
--   domain of the morphism, and associate it to e2 It assumes s1, t1, e2
--   already exist, and that e1 does not exist.
createNodeOnDomain :: NodeId -> NodeId -> GraphMorphism a b -> GraphMorphism a b

-- | This function adds an edge e2 (with source s2 and target t2) to the
--   codomain of the morphism. It assumes that s2,t2 exist, and that e2
--   does not exist
createNodeOnCodomain :: NodeId -> GraphMorphism a b -> GraphMorphism a b

-- | Return the node to which <tt>ln</tt> gets mapped.
applyNode :: GraphMorphism a b -> NodeId -> Maybe NodeId

-- | Return the node to which <tt>le</tt> gets mapped or error in the case
--   of undefined
applyNodeUnsafe :: GraphMorphism a b -> NodeId -> NodeId

-- | Return the edge to which <tt>le</tt> gets mapped.
applyEdge :: GraphMorphism a b -> EdgeId -> Maybe EdgeId

-- | Return the edge to which <tt>le</tt> gets mapped or error in the case
--   of undefined
applyEdgeUnsafe :: GraphMorphism a b -> EdgeId -> EdgeId
nodeRelation :: GraphMorphism a b -> Relation NodeId
edgeRelation :: GraphMorphism a b -> Relation EdgeId

-- | Return the orphan nodes in a graph morphism
orphanNodes :: GraphMorphism a b -> [NodeId]

-- | Return the orphan edges in a graph morphism
orphanEdges :: GraphMorphism a b -> [EdgeId]

-- | Test if a <tt>nac</tt> is partial injective (injective out of
--   <tt>q</tt>)
isPartialInjective :: GraphMorphism a b -> GraphMorphism a b -> Bool
instance (GHC.Read.Read a, GHC.Read.Read b) => GHC.Read.Read (Graph.GraphMorphism.GraphMorphism a b)
instance GHC.Classes.Eq (Graph.GraphMorphism.GraphMorphism a b)
instance GHC.Show.Show (Graph.GraphMorphism.GraphMorphism a b)
instance Abstract.Morphism.Morphism (Graph.GraphMorphism.GraphMorphism a b)
instance Abstract.Valid.Valid (Graph.GraphMorphism.GraphMorphism a b)

module TypedGraph.Graph

-- | A typed graph is a morphism whose codomain is the type graph.
type TypedGraph a b = GraphMorphism a b

-- | Obtain the untyped version of the typed graph
untypedGraph :: TypedGraph a b -> Graph a b

-- | <i>Deprecated: Use extractEdgeType instead</i>
getEdgeType :: TypedGraph a b -> EdgeId -> EdgeId

-- | Given a TypedGraph and a Node in this graph, returns the type of the
--   Node

-- | <i>Deprecated: Use extractNodeType instead</i>
getNodeType :: TypedGraph a b -> NodeId -> NodeId
extractNodeType :: TypedGraph a b -> NodeId -> NodeId
extractEdgeType :: TypedGraph a b -> EdgeId -> EdgeId

-- | Obtain the type graph from a typed graph
typeGraph :: TypedGraph a b -> Graph a b

-- | Test if the typed graph is empty
null :: TypedGraph a b -> Bool

-- | Infinite list of new node instances of a typed graph
newTypedNodes :: TypedGraph a b -> [NodeId]

-- | Infinite list of new edge instances of a typed graph
newTypedEdges :: TypedGraph a b -> [EdgeId]

-- | Obtain a list of tuples <tt>(nodeId, typeId)</tt> for nodes in the
--   graph.
nodesWithType :: TypedGraph a b -> [(NodeId, NodeId)]

-- | Obtain a list of tuples <tt>(edgeId, srcId, tgtId, typeId)</tt> for
--   edges in the graph.
edgesWithType :: TypedGraph a b -> [(EdgeId, NodeId, NodeId, EdgeId)]

module Abstract.AdhesiveHLR
class (Eq m) => Morphism m where type Obj m :: * where {
    type family Obj m :: *;
}

-- | Apply the first argument first (compose f g = g . f)
compose :: Morphism m => m -> m -> m
domain :: Morphism m => m -> Obj m
codomain :: Morphism m => m -> Obj m
id :: Morphism m => Obj m -> m
isMonomorphism :: Morphism m => m -> Bool
isEpimorphism :: Morphism m => m -> Bool
isIsomorphism :: Morphism m => m -> Bool
data AtomicConstraint m
AtomicConstraint :: String -> m -> Bool -> AtomicConstraint m
[name] :: AtomicConstraint m -> String
[morphism] :: AtomicConstraint m -> m
[positive] :: AtomicConstraint m -> Bool
buildNamedAtomicConstraint :: String -> m -> Bool -> AtomicConstraint m

-- | Given an object <tt>G</tt> and a AtomicConstraint <tt>a : P -&gt;
--   C</tt>, check whether <tt>G</tt> satisfies the AtomicConstraint
--   <tt>a</tt>
satisfiesAtomicConstraint :: (FindMorphism m) => Obj m -> AtomicConstraint m -> Bool

-- | Given an object <tt>G</tt> and a list of AtomicConstraints <tt>a : P
--   -&gt; C</tt>, check whether <tt>G</tt> satisfies the all them
satisfiesAllAtomicConstraints :: (FindMorphism m) => Obj m -> [AtomicConstraint m] -> Bool
data Constraint m
Atomic :: AtomicConstraint m -> Constraint m
[atomic] :: Constraint m -> AtomicConstraint m
And :: Constraint m -> Constraint m -> Constraint m
[lc] :: Constraint m -> Constraint m
[rc] :: Constraint m -> Constraint m
Or :: Constraint m -> Constraint m -> Constraint m
[lc] :: Constraint m -> Constraint m
[rc] :: Constraint m -> Constraint m
Not :: Constraint m -> Constraint m
[nc] :: Constraint m -> Constraint m

-- | Given an object <tt>G</tt> and a Constraint <tt>c</tt> (a Boolean
--   formula over atomic constraints), check whether <tt>G</tt> satisfies
--   <tt>c</tt>
satisfiesConstraint :: (FindMorphism m) => Obj m -> Constraint m -> Bool

-- | Given an object <tt>G</tt> and a list of Constraints (Boolean formulas
--   over atomic constraints), check whether <tt>G</tt> satisfies the all
--   them
satisfiesAllConstraints :: (FindMorphism m) => Obj m -> [Constraint m] -> Bool
class Morphism m => EpiPairs m where calculateCommutativeSquares inj m1 m2 = filt where allPairs = createJointlyEpimorphicPairs inj (codomain m1) (codomain m2) filt = filter (\ (x, y) -> compose m1 x == compose m2 y) allPairs

-- | Create all jointly epimorphic pairs of morphisms from the given
--   objects.
--   
--   If the first argument is true, only pairs of monomorphisms are
--   created. Otherwise, pairs of arbitrary morphisms are created.
createJointlyEpimorphicPairs :: EpiPairs m => Bool -> Obj m -> Obj m -> [(m, m)]
createAllSubobjects :: EpiPairs m => Bool -> Obj m -> [m]

-- | Create a special case of jointly epimorphic pairs, where the second
--   morphism is a Nac The first flag indicates Nac satisfability with a
--   monomorphic morphism The second flag indicates that the other morphism
--   is monomorphic
--   
--   FIXME: nacs don't belong in this module
createJointlyEpimorphicPairsFromNAC :: EpiPairs m => DPOConfig -> Obj m -> m -> [(m, m)]
calculateCommutativeSquares :: EpiPairs m => Bool -> m -> m -> [(m, m)]
calculateCommutativeSquaresAlongMonomorphism :: EpiPairs m => (m, Bool) -> (m, Bool) -> [(m, m)]

-- | Type class for morphisms whose category Adhesive and suitable for
--   High-Level Replacement Systems.
--   
--   Mainly provides categorical operations that AdhesiveHLR categories are
--   guaranteed to have.
class (Morphism m) => AdhesiveHLR m

-- | Calculate the pushout between the two given morphisms.
--   
--   Given the morphisms <i>f : A -&gt; B</i> and <i>g : A -&gt; C</i>,
--   respectively, returns the pair of morphisms <i>f' : C -&gt; D</i> and
--   <i>g': B -&gt; D</i> such that the following square is a pushout.
--   
--   <pre>
--        g
--     A──────▶C
--     │       │
--   f │       │ f'
--     ▼       ▼
--     B──────▶D
--        g'
--   </pre>
calculatePushout :: AdhesiveHLR m => m -> m -> (m, m)

-- | Checks if the given sequential morphisms have a pushout complement,
--   assuming they satsify the given restriction.
--   
--   Given the morphisms <i>g : B -&gt; C</i> and <i>f : A -&gt; B</i>,
--   respectively, tests if there exists a pair of morphisms <i>f' : A
--   -&gt; X</i> and <i>g' : X -&gt; B</i> such that the following square
--   is a pushout. Since the category is Adhesive, such a pair is unique.
--   
--   <pre>
--         f
--      A──────▶B
--      │       │
--   g' │       │ g
--      ▼       ▼
--      X──────▶C
--         f'
--   </pre>
--   
--   If the types of the morphisms are known, they should be given. The
--   implementation of this operation may then use them for more efficient
--   calculation.
hasPushoutComplement :: AdhesiveHLR m => (MorphismType, m) -> (MorphismType, m) -> Bool

-- | Calculate the pushout complement for two sequential morphisms,
--   <b>assumes it exists</b>.
--   
--   In order to test if the pushout complement exists, use
--   <a>hasPushoutComplement</a>.
--   
--   Given the morphisms <i>g : B -&gt; C</i> and <i>f : A -&gt; B</i>,
--   respectively, returns the pair of morphisms <i>f' : A -&gt; X</i> and
--   <i>g' : X -&gt; B</i> such that the following square is a pushout.
--   Since the category is Adhesive, such a pair is unique.
--   
--   <pre>
--         f
--      A──────▶B
--      │       │
--   g' │       │ g
--      ▼       ▼
--      X──────▶C
--         f'
--   </pre>
calculatePushoutComplement :: AdhesiveHLR m => m -> m -> (m, m)

-- | Calculate the pullback between the two given morphisms
--   
--   Given two monomorphic morphisms <i>f : A -&gt; C</i> and <i>g : B
--   -&gt; C</i>, respectively, returns the pair of monomorphic morphisms
--   <i>f' : X -&gt; B</i> and <i>g': X -&gt; A</i> such that the following
--   square is a pullback.
--   
--   <pre>
--         g'
--      X──────▶A
--      │       │
--   f' │       │ f
--      ▼       ▼
--      B──────▶C
--         g
--   </pre>
monomorphicPullback :: AdhesiveHLR m => m -> m -> (m, m)

-- | Flag indicating what restrictions are required or assumed of matches.
data MatchRestriction
MonoMatches :: MatchRestriction
AnyMatches :: MatchRestriction

-- | Converts a match restriction to the corresponding MorphismType
matchRestrictionToMorphismType :: MatchRestriction -> MorphismType

-- | Flag indicating the semantics of NAC satisfaction.
data NacSatisfaction
MonomorphicNAC :: NacSatisfaction
PartiallyMonomorphicNAC :: NacSatisfaction
data DPOConfig
DPOConfig :: MatchRestriction -> NacSatisfaction -> DPOConfig
[matchRestriction] :: DPOConfig -> MatchRestriction
[nacSatisfaction] :: DPOConfig -> NacSatisfaction
instance GHC.Show.Show m => GHC.Show.Show (Abstract.AdhesiveHLR.AtomicConstraint m)
instance GHC.Show.Show Abstract.AdhesiveHLR.NacSatisfaction
instance GHC.Classes.Eq Abstract.AdhesiveHLR.NacSatisfaction
instance GHC.Show.Show Abstract.AdhesiveHLR.MatchRestriction
instance GHC.Classes.Eq Abstract.AdhesiveHLR.MatchRestriction
instance Abstract.Valid.Valid m => Abstract.Valid.Valid (Abstract.AdhesiveHLR.AtomicConstraint m)
instance Abstract.Valid.Valid m => Abstract.Valid.Valid (Abstract.AdhesiveHLR.Constraint m)


-- | Provides definitions for the Double-Pushout approach to High-Level
--   Rewriting Systems.
module Abstract.DPO

-- | A Double-Pushout production.
--   
--   Consists of two morphisms <i><a>left</a> : K -&gt; L</i> and
--   <i><a>right</a> : K -&gt; R</i>, as well as a set of <a>nacs</a> <i>L
--   -&gt; Ni</i>.
data Production m

-- | Construct a production from the morphism <i>l : K -&gt; L</i>, the
--   morphism <i>r : K -&gt; R</i>, and the nacs <i>L -&gt; Ni</i>,
--   respectively.
--   
--   Note: this doesn't check that the production is valid.
buildProduction :: m -> m -> [m] -> Production m

-- | Returns the morphism <i>K -&gt; L</i> of the given production
getLHS :: Production m -> m

-- | Returns the morphism <i>K -&gt; R</i> of the given production
getRHS :: Production m -> m

-- | Returns the set of nacs <i>L -&gt; Ni</i> of the given production
getNACs :: Production m -> [m]
data DPOConfig
DPOConfig :: MatchRestriction -> NacSatisfaction -> DPOConfig
[matchRestriction] :: DPOConfig -> MatchRestriction
[nacSatisfaction] :: DPOConfig -> NacSatisfaction

-- | Flag indicating what restrictions are required or assumed of matches.
data MatchRestriction
MonoMatches :: MatchRestriction
AnyMatches :: MatchRestriction

-- | Converts a match restriction to the corresponding MorphismType
matchRestrictionToMorphismType :: MatchRestriction -> MorphismType

-- | Flag indicating the semantics of NAC satisfaction.
data NacSatisfaction
MonomorphicNAC :: NacSatisfaction
PartiallyMonomorphicNAC :: NacSatisfaction

-- | Class for morphisms whose category is Adhesive-HLR, and which can be
--   used for double-pushout transformations.
class (AdhesiveHLR m, FindMorphism m) => DPO m

-- | Inverts a production, adjusting the NACs accordingly. Needs
--   information of nac injective satisfaction (in second order) and
--   matches injective.
invertProduction :: DPO m => DPOConfig -> Production m -> Production m

-- | Given a production <i>L ←l- K -r→ R</i> and a NAC morphism <i>n : L
--   -&gt; N</i>, obtain a set of NACs <i>n'i : R -&gt; N'i</i> that is
--   equivalent to the original NAC.
shiftNacOverProduction :: DPO m => DPOConfig -> Production m -> m -> [m]

-- | Check if the second morphism is monomorphic outside the image of the
--   first morphism.
isPartiallyMonomorphic :: DPO m => m -> m -> Bool

-- | Verifies if the gluing conditions for a production <i>p</i> are
--   satisfied by a match <i>m</i>
satisfiesGluingConditions :: DPO m => DPOConfig -> Production m -> m -> Bool

-- | True if the given match satisfies all NACs of the given production.
satisfiesNACs :: DPO m => DPOConfig -> Production m -> m -> Bool

-- | True if the given match satisfies the gluing condition and NACs of the
--   given production.
satisfiesRewritingConditions :: DPO m => DPOConfig -> Production m -> m -> Bool

-- | Check gluing conditions and the NACs satisfaction for a pair of
--   matches <tt>inj</tt> only indicates if the match is injective, this
--   function does not checks it
satisfyRewritingConditions :: DPO m => DPOConfig -> (Production m, m) -> (Production m, m) -> Bool

-- | Obtain all matches from the production into the given object, even if
--   they aren't applicable.
--   
--   When given <a>MonoMatches</a>, only obtains monomorphic matches.
findAllMatches :: (DPO m) => DPOConfig -> Production m -> Obj m -> [m]

-- | Obtain the matches from the production into the given object that
--   satisfiy the NACs and gluing conditions.
--   
--   When given <a>MonoMatches</a>, only obtains monomorphic matches.
findApplicableMatches :: (DPO m) => DPOConfig -> Production m -> Obj m -> [m]

-- | Given a match and a production, calculates the double-pushout diagram
--   for the corresponding transformation.
--   
--   Given match <i>m : L -&gt; G</i> and the production <i>L ←l- K -r→
--   R</i> such that <tt><a>satisfiesRewritingConditions</a> _ _ p m ==
--   True</tt>, returns <i>k</i>, <i>n</i>, <i>f</i> and <i>g</i>
--   (respectively) such that the following two squares are pushouts.
--   
--   <pre>
--        l        r
--     L◀──────K──────▶R
--     │       │       │
--   m │       │ k     │ n
--     ▼       ▼       ▼
--     G◀──────D──────▶H
--          f     g
--   </pre>
--   
--   Note: this doesn't test whether the match is for the actual
--   production, nor if the match satisfies all application conditions.
calculateDPO :: AdhesiveHLR m => m -> Production m -> (m, m, m, m)

-- | Given a match and a production, calculate the calculateComatch for the
--   corresponding transformation.
--   
--   Given match <i>m : L -&gt; G</i> and the production <tt>p = <i>L ←l- K
--   -r→ R</i></tt> such that <tt><a>satisfiesRewritingConditions</a> _ _ p
--   m == True</tt>, returns <i>n</i> such that the following two squares
--   are pushouts.
--   
--   <pre>
--        l        r
--     L◀──────K──────▶R
--     │       │       │
--   m │       │       │ n
--     ▼       ▼       ▼
--     G◀──────D──────▶H
--   </pre>
--   
--   Note: this doesn't test whether the match is for the actual
--   production, nor if the match satisfies all application conditions.
calculateComatch :: AdhesiveHLR m => m -> Production m -> m

-- | Given a match and a production, obtain the rewritten object.
--   
--   <tt>rewrite match production</tt> is equivalent to <tt><a>codomain</a>
--   (<a>calculateComatch</a> match production)</tt>
rewrite :: AdhesiveHLR m => m -> Production m -> Obj m

-- | Discards the NACs of a production and inverts it.
invertProductionWithoutNacs :: Production m -> Production m

-- | Given a morphism <i>m : L -&gt; L'</i> and a NAC <i>n : L -&gt; N</i>,
--   obtains an equivalent set of NACs <i>n'i : L' -&gt; N'i</i> that is
--   equivalent to the original NAC.
nacDownwardShift :: EpiPairs m => DPOConfig -> m -> m -> [m]
instance GHC.Read.Read m => GHC.Read.Read (Abstract.DPO.Production m)
instance GHC.Show.Show m => GHC.Show.Show (Abstract.DPO.Production m)
instance GHC.Classes.Eq m => GHC.Classes.Eq (Abstract.DPO.Production m)
instance (Abstract.Morphism.Morphism m, Abstract.Valid.Valid m, GHC.Classes.Eq (Abstract.Morphism.Obj m)) => Abstract.Valid.Valid (Abstract.DPO.Production m)


-- | A High-Level Replacement (HLR) system, along with a starting state,
--   induces a state space that may be seen as a transition system or
--   Kripke structure. This module provides a data structure for
--   representing the explored portion of such a state space, as well as a
--   monad for doing said exploration.
module Abstract.DPO.StateSpace

-- | A data structure storing the explored portion of the state space
--   induced by a High-Level Replacement (HLR) system.
--   
--   The states are objects in the category, up to isomorphism. Such states
--   are identified by numeric indices. The transitions are specified as
--   pairs of indices, so multiple transitions between the same two states
--   are seen as a single one.
--   
--   The states are annotated with the set of predicates that hold in them.
--   Predicates are expressed as rules, and a predicate holds in a state if
--   the rule is applicable.
data StateSpace m

-- | An empty state space for the HLR system defined by the given
--   productions, with the given configuration of the DPO semantics.
empty :: DPOConfig -> [Production m] -> [(String, Production m)] -> StateSpace m

-- | Obtain the set of (explored) indexed states in a state space.
states :: StateSpace m -> IntMap (State m)

-- | Obtain the set of (explored) transitions in a state space.
transitions :: StateSpace m -> Set (Int, Int)

-- | Tries to find an isomorphic object in the state space, returning it
--   along with its index.
searchForState :: forall m. (DPO m) => Obj m -> StateSpace m -> Maybe (Int, State m)

-- | Converts the state space to a transition system that may be used for
--   model checking
toKripkeStructure :: StateSpace m -> KripkeStructure String

-- | A monad for exploring the state space of a High-Level Replacement
--   System.
--   
--   Provides a static configuration of the DPO semantics and a static set
--   of
data StateSpaceBuilder m a

-- | Runs the builder with the given configuration and initial state space.
runStateSpaceBuilder :: StateSpaceBuilder m a -> StateSpace m -> (a, StateSpace m)

-- | Runs the builder with the given configuration and state space,
--   providing only the computed value and ignoring the resulting state
--   space.
evalStateSpaceBuilder :: StateSpaceBuilder m a -> StateSpace m -> a

-- | Runs the builder with the given configuration and state space,
--   ignoring the computed value and providing only the resulting state
--   space.
execStateSpaceBuilder :: StateSpaceBuilder m a -> StateSpace m -> StateSpace m

-- | Gets the configuration of DPO semantics for this builder.
getDpoConfig :: StateSpaceBuilder m DPOConfig

-- | Gets the productions of the HLR system being explored in this builder.
getProductions :: StateSpaceBuilder m [Production m]

-- | Adds the given state if an isomorphic one doesn't exist. Returns a
--   tuple <tt>(index, isNew)</tt>, where <tt>index</tt> is the index of
--   the state and <tt>isNew</tt> is true if no isomorphic state existed.
putState :: (DPO m) => Obj m -> StateSpaceBuilder m (Int, Bool)

-- | Adds a transition between the states with the given indices. Does
--   <b>not</b> check if such states exist.
putTransition :: (Int, Int) -> StateSpaceBuilder m ()

-- | Tries to find an isomorphic object in the current state space,
--   returning its index.
findIsomorphicState :: (DPO m) => Obj m -> StateSpaceBuilder m (Maybe (Int, State m))

-- | Finds all transformations of the given state with the productions of
--   the HLR system being explored, adding them to the state space. Returns
--   a list of the successor states as <tt>(index, object, isNew)</tt>,
--   where <tt>isNew</tt> indicates that the state was not present in the
--   state space before.
expandSuccessors :: forall m. DPO m => (Int, Obj m) -> StateSpaceBuilder m [(Int, Obj m, Bool)]

-- | Runs a depth-first search on the state space, starting on the given
--   object and limiting the depth to the given number.
depthSearch :: forall m. DPO m => Int -> Obj m -> StateSpaceBuilder m ()
instance Control.Monad.State.Class.MonadState (Abstract.DPO.StateSpace.StateSpace m) (Abstract.DPO.StateSpace.StateSpaceBuilder m)
instance GHC.Base.Monad (Abstract.DPO.StateSpace.StateSpaceBuilder m)
instance GHC.Base.Applicative (Abstract.DPO.StateSpace.StateSpaceBuilder m)
instance GHC.Base.Functor (Abstract.DPO.StateSpace.StateSpaceBuilder m)

module Analysis.CriticalSequence

-- | Data representing the type of a <tt>CriticalPair</tt>
data CriticalSequenceType

-- | resp. delete-use
ProduceUse :: CriticalSequenceType

-- | resp. produce-dangling
RemoveDangling :: CriticalSequenceType

-- | resp. produce-forbid
DeleteForbid :: CriticalSequenceType

-- | resp. inverted delete-use
DeliverDelete :: CriticalSequenceType

-- | resp. inverted produce-dangling
DeliverDangling :: CriticalSequenceType

-- | resp. inverted produce-forbid
ForbidProduce :: CriticalSequenceType

-- | A Critical Sequence is defined as two matches (m1,m2) from the left
--   side of their rules to a same graph.
--   
--   This diagram shows graphs and morphisms names used in the algorithms
--   below
--   
--   p1 = production (L1,K1,R1,[N1]) (N1 from L1)
--   
--   invLeft = production (R1,K1,L1,[N1]) (N1 from R1)
--   
--   p2 = production (L2,K2,R2,[N2])
--   
--   <pre>
--                    N1    N2
--                    ^      ^
--          l     r   │      │n
--     L1◀─────K1────▶R1    L2◀────K2─────▶R2
--     │       │       \   /       │       │
--   m1│      k│     m1'\ /m2'     │       │
--     ▼       ▼         ▼         ▼       ▼
--     P1◀─────D1───────▶G◀───────D2──────▶P2
--         r'       l'
--   </pre>
--   
--   m2 :: from L2 to P1
--   
--   h21 :: from L2 to D1
--   
--   q21 (nacMatch) :: from N2 to P1
data CriticalSequence m

-- | Given two productions <tt>p1</tt> and <tt>p2</tt>, finds the Critical
--   sequences in which the application of <tt>p1</tt> enables the
--   application of <tt>p2</tt>
findTriggeringCriticalSequences :: (EpiPairs m, DPO m) => DPOConfig -> Production m -> Production m -> [CriticalSequence m]

-- | Returns the Critical Sequences with rule names
namedCriticalSequences :: (EpiPairs m, DPO m) => DPOConfig -> [NamedRule m] -> [NamedCriticalPairs m]

-- | All ProduceUse caused by the derivation of <tt>l</tt> before
--   <tt>r</tt>.
--   
--   Rule <tt>p1</tt> causes a produce-use dependency with <tt>p2</tt> if
--   rule <tt>p1</tt> creates something that is used by <tt>p2</tt>. Verify
--   the non existence of h21: L2 -&gt; D1 such that d1 . h21 = m2'.
findAllProduceUse :: (DPO m, EpiPairs m) => DPOConfig -> Production m -> Production m -> [CriticalSequence m]

-- | All RemoveDangling caused by the derivation of <tt>p1</tt> before
--   <tt>p2</tt>.
--   
--   Rule <tt>p1</tt> causes a remove-dangling dependency with <tt>p2</tt>
--   if rule <tt>p1</tt> deletes something that enables <tt>p2</tt>.
findAllRemoveDangling :: (EpiPairs m, DPO m) => DPOConfig -> Production m -> Production m -> [CriticalSequence m]

-- | All DeleteForbid caused by the derivation of <tt>p1</tt> before
--   <tt>r</tt>. Rule <tt>p1</tt> causes a delete-forbid dependency with
--   <tt>p2</tt> if some NAC in <tt>p2</tt> turns satisfied after the
--   aplication of <tt>p1</tt>
findAllDeleteForbid :: (DPO m, EpiPairs m) => DPOConfig -> Production m -> Production m -> [CriticalSequence m]

-- | All DeliverDelete caused by the derivation of <tt>p1</tt> before
--   <tt>r</tt>.
--   
--   Rule <tt>p1</tt> causes a deliver-delete dependency with <tt>p2</tt>
--   if rule <tt>p2</tt> deletes something that is used by <tt>p2</tt>,
--   Verify the non existence of h12: L1 -&gt; D2 such that d2 . h12 = m1'.
findAllDeliverDelete :: (DPO m, EpiPairs m) => DPOConfig -> Production m -> Production m -> [CriticalSequence m]

-- | All ForbidProduce caused by the derivation of <tt>p1</tt> before
--   <tt>p2</tt>.
--   
--   Rule <tt>p1</tt> causes a forbid-produce dependency with <tt>p2</tt>
--   if some NAC in right of <tt>p1</tt> turns satisfied after the
--   aplication of <tt>p2</tt>.
findAllForbidProduce :: (DPO m, EpiPairs m) => DPOConfig -> Production m -> Production m -> [CriticalSequence m]

-- | All DeliverDangling caused by the derivation of <tt>p1</tt> before
--   <tt>p2</tt>.
--   
--   Rule <tt>p1</tt> causes a deliver-delete dependency with <tt>p2</tt>
--   if rule <tt>p2</tt> creates something that disables the inverse of
--   <tt>p1</tt>.
findAllDeliverDangling :: (DPO m, EpiPairs m) => DPOConfig -> Production m -> Production m -> [CriticalSequence m]

-- | Returns the matches (m1, m2)
getCriticalSequenceMatches :: CriticalSequence m -> Maybe (m, m)

-- | Returns the comatches (m1', m2')
getCriticalSequenceComatches :: CriticalSequence m -> (m, m)

-- | Returns the nac match of a <a>CriticalSequence</a>
getNacMatchOfCriticalSequence :: CriticalSequence m -> Maybe m

-- | Returns the nac index of a <a>CriticalSequence</a>
getNacIndexOfCriticalSequence :: CriticalSequence m -> Maybe Int

-- | Returns the type of a <a>CriticalSequence</a>
getCriticalSequenceType :: CriticalSequence m -> CriticalSequenceType
instance GHC.Show.Show m => GHC.Show.Show (Analysis.CriticalSequence.CriticalSequence m)
instance GHC.Classes.Eq m => GHC.Classes.Eq (Analysis.CriticalSequence.CriticalSequence m)
instance GHC.Show.Show Analysis.CriticalSequence.CriticalSequenceType
instance GHC.Classes.Eq Analysis.CriticalSequence.CriticalSequenceType

module Analysis.ConcurrentRules
data CRDependencies
AllOverlapings :: CRDependencies
OnlyDependency :: CRDependencies

-- | Generates the Concurrent Rules for a given list of GraphRules
--   following the order of the elements in the list.
allConcurrentRules :: (DPO m, EpiPairs m, Eq (Obj m), Valid m) => CRDependencies -> DPOConfig -> [AtomicConstraint m] -> [Production m] -> [Production m]

-- | Generates the Concurrent Rule with the least disjoint EpiPair for a
--   given list of GraphRules (following the order of the elements in the
--   list).
maxConcurrentRule :: (DPO m, EpiPairs m, Eq (Obj m), Valid m) => CRDependencies -> DPOConfig -> [AtomicConstraint m] -> [Production m] -> Maybe (Production m)

module Analysis.CriticalPairs

-- | Data representing the type of a <a>CriticalPair</a>
data CriticalPairType
FreeOverlap :: CriticalPairType
DeleteUse :: CriticalPairType
ProduceForbid :: CriticalPairType
ProduceDangling :: CriticalPairType

-- | A Critical Pair is defined as two matches (m1,m2) from the left side
--   of their rules to a same graph. It assumes that the derivation of the
--   rule with match <tt>m1</tt> causes a conflict with the rule with match
--   <tt>m2</tt>
--   
--   This diagram shows graphs and morphisms names used in the algorithms
--   below
--   
--   p1 = production (L1,K1,R1,[N1])
--   
--   p2 = production (L2,K2,R2,[N2])
--   
--   <pre>
--                     N1    N2
--                     ^      ^
--           r     l   │      │n
--      R1◀─────K1────▶L1    L2◀────K2─────▶R2
--      │       │       \   /       │       │
--   m1'│      k│      m1\ /m2      │       │
--      ▼       ▼         ▼         ▼       ▼
--      P1◀─────D1───────▶G◀───────D2──────▶P2
--          r'       l'
--   </pre>
--   
--   m2' :: from L2 to P1
--   
--   h21 :: from L2 to D1
--   
--   q21 (nacMatch) :: from N2 to P1
data CriticalPair m

-- | Finds all Critical Pairs between two given Productions
findCriticalPairs :: (EpiPairs m, DPO m) => DPOConfig -> Production m -> Production m -> [CriticalPair m]

-- | Returns the Critical Pairs with rule names
namedCriticalPairs :: (EpiPairs m, DPO m) => DPOConfig -> [NamedRule m] -> [NamedCriticalPairs m]

-- | All DeleteUse caused by the derivation of <tt>p1</tt> before
--   <tt>p2</tt>. It occurs when <tt>p1</tt> deletes something used by
--   <tt>p2</tt>.
findAllDeleteUse :: (EpiPairs m, DPO m) => DPOConfig -> Production m -> Production m -> [CriticalPair m]

-- | All ProduceForbid caused by the derivation of <tt>p1</tt> before
--   <tt>p2</tt>.
--   
--   Rule <tt>p1</tt> causes a produce-forbid conflict with <tt>p2</tt> if
--   some NAC in <tt>p2</tt> fails to be satisfied after the aplication of
--   <tt>p1</tt>.
findAllProduceForbid :: (EpiPairs m, DPO m) => DPOConfig -> Production m -> Production m -> [CriticalPair m]

-- | All ProduceDangling caused by the derivation of <tt>p1</tt> before
--   <tt>p2</tt>. It occurs when <tt>p1</tt> creates something that unable
--   <tt>p2</tt>.
findAllProduceDangling :: (EpiPairs m, DPO m) => DPOConfig -> Production m -> Production m -> [CriticalPair m]

-- | Returns the matches (m1,m2)
getCriticalPairMatches :: CriticalPair m -> (m, m)

-- | Returns the comatches (m1',m2')
getCriticalPairComatches :: CriticalPair m -> Maybe (m, m)

-- | Returns the nac index of a <a>CriticalPair</a>
getNacIndexOfCriticalPair :: CriticalPair m -> Maybe Int

-- | Returns the nac match of a <a>CriticalPair</a>
getNacMatchOfCriticalPair :: CriticalPair m -> Maybe m

-- | Returns the type of a Critical Pair
getCriticalPairType :: CriticalPair m -> CriticalPairType

-- | Rule <tt>p1</tt> is in a delete-use conflict with <tt>p2</tt> if
--   <tt>p1</tt> deletes something that is used by <tt>p2</tt>.
--   
--   Verifies the non existence of h21: L2 -&gt; D1 such that d1 . h21 = m2
isDeleteUse :: DPO m => DPOConfig -> Production m -> (m, m) -> Bool
instance GHC.Show.Show m => GHC.Show.Show (Analysis.CriticalPairs.CriticalPair m)
instance GHC.Classes.Eq m => GHC.Classes.Eq (Analysis.CriticalPairs.CriticalPair m)
instance GHC.Show.Show Analysis.CriticalPairs.CriticalPairType
instance GHC.Classes.Eq Analysis.CriticalPairs.CriticalPairType

module TypedGraph.Morphism
data TypedGraphMorphism a b

-- | Creates a TypedGraphMorphism mapping the same elements of theirs
--   codomains, from <tt>tgm1</tt> to <tt>tgm2</tt>
idMap :: GraphMorphism a b -> GraphMorphism a b -> TypedGraphMorphism a b

-- | Test if a <tt>nac</tt> is partial injective (injective out of
--   <tt>m</tt>)
isPartialInjective :: TypedGraphMorphism a b -> TypedGraphMorphism a b -> Bool

-- | Invert a typed graph morphism
invert :: TypedGraphMorphism a b -> TypedGraphMorphism a b

-- | Return the nodes in the domain of a given <tt>TypedGraphMorphism</tt>
nodesFromDomain :: TypedGraphMorphism a b -> [NodeId]

-- | Return the edges in the domain of a given <tt>TypedGraphMorphism</tt>
edgesFromDomain :: TypedGraphMorphism a b -> [EdgeId]

-- | Return the nodes in the codomain of a given
--   <tt>TypedGraphMorphism</tt>
nodesFromCodomain :: TypedGraphMorphism a b -> [NodeId]

-- | Return the edges in the codomain of a given
--   <tt>TypedGraphMorphism</tt>
edgesFromCodomain :: TypedGraphMorphism a b -> [EdgeId]

-- | Return the domain graph
graphDomain :: TypedGraphMorphism a b -> Graph a b

-- | Return the codomain graph
graphCodomain :: TypedGraphMorphism a b -> Graph a b
mapping :: TypedGraphMorphism a b -> GraphMorphism a b

-- | Given a TypedGraphMorphism <tt><i><b>t</b>: G1 -&gt; G2</i></tt> and a
--   node <tt><b>n</b></tt> in <tt>G1</tt>, it returns the node in
--   <tt>G2</tt> to which <tt><b>n</b></tt> gets mapped
applyNode :: TypedGraphMorphism a b -> NodeId -> Maybe NodeId

-- | Given a TypedGraphMorphism <tt><i><b>t</b>: G1 -&gt; G2</i></tt> and
--   an edge <tt><b>e</b></tt> in <tt>G1</tt>, it returns the edge in
--   <tt>G2</tt> to which <tt><b>e</b></tt> gets mapped
applyEdge :: TypedGraphMorphism a b -> EdgeId -> Maybe EdgeId

-- | Given two <tt>TypedGraph</tt>s <tt>G1</tt> and <tt>G2</tt> and a
--   simple <tt>GraphMorphism</tt> between them, it returns a
--   <tt>TypedGraphMorphism</tt> from <tt>G1</tt> to <tt>G2</tt>
buildTypedGraphMorphism :: TypedGraph a b -> TypedGraph a b -> GraphMorphism a b -> TypedGraphMorphism a b

-- | TODO: Find a better name for this function, that was repeated both
--   here and in the GraphRule archive | Given the left-hand-side morphism
--   of a rule <i>l : K -&gt; L</i>, a match <i>m : L -&gt; G</i> for this
--   rule, an element <b><i>e</i></b> (that can be either a
--   <b><i>Node</i></b> or an <b><i>Edge</i></b>) and two functions
--   <i>apply</i> (for applying that element in a TypedGraphMorphism) and
--   <i>list</i> (to get all the corresponding elements in the domain of
--   m), it returns true if <i>e</i> is deleted by this rule for the given
--   match
checkDeletion :: Eq t => TypedGraphMorphism a b -> TypedGraphMorphism a b -> (TypedGraphMorphism a b -> t -> Maybe t) -> (TypedGraphMorphism a b -> [t]) -> t -> Bool

-- | Remove a node from the domain of a typed graph morphism
removeNodeFromDomain :: NodeId -> TypedGraphMorphism a b -> TypedGraphMorphism a b

-- | Remove an edge from the domain of a typed graph morphism
removeEdgeFromDomain :: EdgeId -> TypedGraphMorphism a b -> TypedGraphMorphism a b

-- | Remove a node from the codomain of a typed graph morphism
removeNodeFromCodomain :: NodeId -> TypedGraphMorphism a b -> TypedGraphMorphism a b

-- | Remove an edge from the domain of a typed graph morphism
removeEdgeFromCodomain :: EdgeId -> TypedGraphMorphism a b -> TypedGraphMorphism a b

-- | Given a <tt>TypedGraphMorphism</tt> <tt><b>t</b></tt>and a node
--   <tt>n</tt> in the domain of <tt><b>t</b></tt>, return the node in the
--   image of <tt>t</tt> to which <tt>n</tt> gets mapped or error in the
--   case of undefined
applyNodeUnsafe :: TypedGraphMorphism a b -> NodeId -> NodeId

-- | Given a <tt>TypedGraphMorphism</tt> <tt><b>t</b></tt>and an edge
--   <tt>e</tt> in the domain of <tt><b>t</b></tt>, return the edge in the
--   image of <tt>t</tt> to which <tt>e</tt> gets mapped or error in the
--   case of undefined
applyEdgeUnsafe :: TypedGraphMorphism a b -> EdgeId -> EdgeId

-- | This function adds an edge e1 (with source s1, target t1 and type tp)
--   to the domain of the typed graph morphism, and associate it to e2 It
--   assumes s1, t1, e2, tp already exist, and that e1 does not exist.
createEdgeOnDomain :: EdgeId -> NodeId -> NodeId -> EdgeId -> EdgeId -> TypedGraphMorphism a b -> TypedGraphMorphism a b

-- | This function adds an edge e2 (with source s2, target t2 and type tp)
--   to the codomain of the typed graph morphism It assumes s2, t2, tp
--   already exist, and that e2 does not exist.
createEdgeOnCodomain :: EdgeId -> NodeId -> NodeId -> EdgeId -> TypedGraphMorphism a b -> TypedGraphMorphism a b

-- | This function adds a node n1 (type tp) to the domain of the typed
--   graph morphism, and associate it to n2 It assumes n2 and tp already
--   exist, and that n1 does not exist.
createNodeOnDomain :: NodeId -> NodeId -> NodeId -> TypedGraphMorphism a b -> TypedGraphMorphism a b

-- | This function adds a node n2 (type tp) to the codomain of the typed
--   graph morphism It assumes tp already exist, and that n2 does not
--   exist.
createNodeOnCodomain :: NodeId -> NodeId -> TypedGraphMorphism a b -> TypedGraphMorphism a b

-- | updates a typed graph morphism, mapping edge e1 to edge e2. It assumes
--   both edges already exist.
updateEdgeRelation :: EdgeId -> EdgeId -> TypedGraphMorphism a b -> TypedGraphMorphism a b

-- | updates a typed graph morphism, mapping node n1 to node n2. It assumes
--   both nodes already exist.
updateNodeRelation :: NodeId -> NodeId -> NodeId -> TypedGraphMorphism a b -> TypedGraphMorphism a b

-- | Given a <tt>TypedGraphMorphism</tt>, return its orphan nodes
orphanTypedNodes :: TypedGraphMorphism a b -> [NodeId]

-- | Given a <tt>TypedGraphMorphism</tt>, return its orphan edges
orphanTypedEdges :: TypedGraphMorphism a b -> [EdgeId]

module TypedGraph.GraphRule
type GraphRule a b = Production (TypedGraphMorphism a b)

-- | Returns the morphism <i>K -&gt; L</i> of the given production
getLHS :: Production m -> m

-- | Returns the morphism <i>K -&gt; R</i> of the given production
getRHS :: Production m -> m

-- | Returns the set of nacs <i>L -&gt; Ni</i> of the given production
getNACs :: Production m -> [m]

-- | Discards the NACs of a production and inverts it.
invertProductionWithoutNacs :: Production m -> Production m

-- | Return the nodes deleted by a rule
deletedNodes :: GraphRule a b -> [NodeId]

-- | Return the edges deleted by a rule
deletedEdges :: GraphRule a b -> [EdgeId]

-- | Return the nodes created by a rule
createdNodes :: GraphRule a b -> [NodeId]

-- | Return the edges created by a rule
createdEdges :: GraphRule a b -> [EdgeId]

-- | TODO: Find a better name for this function, that was repeated both
--   here and in the GraphRule archive | Given the left-hand-side morphism
--   of a rule <i>l : K -&gt; L</i>, a match <i>m : L -&gt; G</i> for this
--   rule, an element <b><i>e</i></b> (that can be either a
--   <b><i>Node</i></b> or an <b><i>Edge</i></b>) and two functions
--   <i>apply</i> (for applying that element in a TypedGraphMorphism) and
--   <i>list</i> (to get all the corresponding elements in the domain of
--   m), it returns true if <i>e</i> is deleted by this rule for the given
--   match
checkDeletion :: Eq t => TypedGraphMorphism a b -> TypedGraphMorphism a b -> (TypedGraphMorphism a b -> t -> Maybe t) -> (TypedGraphMorphism a b -> [t]) -> t -> Bool
instance Abstract.DPO.DPO (TypedGraph.Morphism.Core.TypedGraphMorphism a b)

module SndOrder.Morphism

-- | A morphism between two rules.
--   
--   The following diagram illustrates such a morphism, omiting the NACs.
--   
--   <pre>
--            l1      r1
--        L1◀─────K1─────▶R1
--        │       │       │
--   mapL │   mapK│   mapR│
--        ▼       ▼       ▼
--        L2◀─────K2─────▶R2
--            l2      r2
--   </pre>
--   
--   domain = (l1,r1)
--   
--   codomain = (l2,r2)
--   
--   mappingLeft = mapL
--   
--   mappingInterface = mapK
--   
--   mappingRight = mapR
--   
--   TODO: Make polymorphic on the type of morphism?
data RuleMorphism a b
ruleMorphism :: Production (TypedGraphMorphism a b) -> Production (TypedGraphMorphism a b) -> TypedGraphMorphism a b -> TypedGraphMorphism a b -> TypedGraphMorphism a b -> RuleMorphism a b
mappingLeft :: RuleMorphism a b -> TypedGraphMorphism a b
mappingInterface :: RuleMorphism a b -> TypedGraphMorphism a b
mappingRight :: RuleMorphism a b -> TypedGraphMorphism a b

-- | Given the morphisms <i>k1 : X -&gt; Y</i>, <i>s1 : X -&gt; Z</i>,
--   <i>k2 : W -&gt; Y</i> and <i>s2 : W -&gt; Z</i>, respectively, creates
--   the monomorphic morphism <i>x : Y -&gt; Z</i>, where the following
--   diagram commutes:
--   
--   <pre>
--      k1
--   X ───▶Y
--    \   / ▲
--   s1\ /x  \k2
--      ▼     \
--      Z◀──── W
--         s2
--   </pre>
--   
--   TODO: explain the errors in this function. what are preconditions for
--   them not to occur?!?
commutingMorphismSameDomain :: TypedGraphMorphism a b -> TypedGraphMorphism a b -> TypedGraphMorphism a b -> TypedGraphMorphism a b -> TypedGraphMorphism a b

-- | Given the morphisms <i>k1 : Y -&gt; X</i>, <i>s1 : Z -&gt; X</i>,
--   <i>k2 : W -&gt; Y</i> and <i>s2 : W -&gt; Z</i>, respectively, creates
--   the monomorphic morphism <i>a : X -&gt; Y</i>, where the following
--   diagram commutes:
--   
--   <pre>
--       k1
--    X ◀─── Y
--    ▲     / ▲
--   s1\   /x  \k2
--      \ ▼     \
--       Z◀──── W
--          s2
--   </pre>
--   
--   TODO: explain the errors in this function. what are preconditions for
--   them not to occur?!?
commutingMorphismSameCodomain :: TypedGraphMorphism a b -> TypedGraphMorphism a b -> TypedGraphMorphism a b -> TypedGraphMorphism a b -> TypedGraphMorphism a b
instance (GHC.Read.Read a, GHC.Read.Read b) => GHC.Read.Read (SndOrder.Morphism.RuleMorphism a b)
instance GHC.Show.Show (SndOrder.Morphism.RuleMorphism a b)
instance GHC.Classes.Eq (SndOrder.Morphism.RuleMorphism a b)
instance Abstract.Valid.Valid (SndOrder.Morphism.RuleMorphism a b)
instance Abstract.Morphism.Morphism (SndOrder.Morphism.RuleMorphism a b)
instance Abstract.Morphism.FindMorphism (SndOrder.Morphism.RuleMorphism a b)
instance Abstract.AdhesiveHLR.EpiPairs (SndOrder.Morphism.RuleMorphism a b)
instance Abstract.AdhesiveHLR.AdhesiveHLR (SndOrder.Morphism.RuleMorphism a b)

module SndOrder.Rule

-- | A second order rule:
--   
--   <pre>
--         nl       nr
--     NL◀─────&lt;NK&gt;─────▶NR
--      ▲        ▲        ▲
--   nacL\    nacK\    nacR\
--        \        \        \
--         \   ll   \   lr   \
--         LL◀─────&lt;LK&gt;─────▶LR
--         ▲        ▲        ▲
--    leftL│   leftK│   leftR│
--         │        │        │
--         │    kl  │    kr  │
--         KL◀─────&lt;KK&gt;─────▶KR
--         │        │        │
--   rightL│  rightK│  rightR│
--         │        │        │
--         ▼    rl  ▼    rr  ▼
--         RL◀─────&lt;RK&gt;─────▶RR
--   </pre>
--   
--   domain rule = (ll,lr)
--   
--   interface rule = (kl,kr)
--   
--   codomain rule (rl,rr)
--   
--   nac rule = (nl,nr)
--   
--   nacs = set of: domain rule, nac rule, nacL, nacK, nacR
--   
--   left = domain rule, interface rule, leftL, leftK, leftR
--   
--   right = interface rule, codomain rule, rightL, rightK, rightR
type SndOrderRule a b = Production (RuleMorphism a b)

-- | Adds the minimal safety nacs needed to this production always produce
--   a second order rule. If the nacs to be added not satisfies the others
--   nacs, then it do not need to be added.
addMinimalSafetyNacs :: DPOConfig -> SndOrderRule a b -> SndOrderRule a b
applySndOrderRule :: DPOConfig -> (String, SndOrderRule a b) -> (String, GraphRule a b) -> [(String, GraphRule a b)]

-- | Receives a function that works with a second order and a first order
--   rule. Apply this function on all possible combinations of rules.
applySecondOrder :: ((String, SndOrderRule a b) -> (String, GraphRule a b) -> [t]) -> [(String, GraphRule a b)] -> [(String, SndOrderRule a b)] -> [t]
instance Abstract.DPO.DPO (SndOrder.Morphism.RuleMorphism a b)


module Analysis.Interlevel.EvolutionarySpans

-- | Given a list of second order rules, calculate all Evolutionary Spans
--   This analysis is supposed to be symmetric, here is considering only
--   this case
allEvolSpans :: DPOConfig -> [(String, SndOrderRule a b)] -> [(String, [EvoSpan a b])]

-- | Represents the two evolutionary matches, and the kind of span
data EvoSpan a b
leftMatch :: EvoSpan a b -> RuleMorphism a b
rightMatch :: EvoSpan a b -> RuleMorphism a b
cpe :: EvoSpan a b -> CPE
instance GHC.Show.Show (Analysis.Interlevel.EvolutionarySpans.EvoSpan a b)
instance GHC.Classes.Eq (Analysis.Interlevel.EvolutionarySpans.EvoSpan a b)
instance GHC.Show.Show Analysis.Interlevel.EvolutionarySpans.CPE
instance GHC.Classes.Eq Analysis.Interlevel.EvolutionarySpans.CPE


module Analysis.Interlevel.InterLevelCP

-- | Matches the second order rule with the first order, and calls theirs
--   critical pairs
interLevelCP :: DPOConfig -> (String, SndOrderRule a b) -> (String, GraphRule a b) -> [(String, String, Int, InterLevelCP a b)]
data InterLevelCP a b
InterLevelCP :: RuleMorphism a b -> TypedGraphMorphism a b -> InterLevelCP a b
[sndOrderMatch] :: InterLevelCP a b -> RuleMorphism a b
[fstOrderMatch] :: InterLevelCP a b -> TypedGraphMorphism a b
instance GHC.Show.Show (Analysis.Interlevel.InterLevelCP.InterLevelCP a b)
instance GHC.Classes.Eq (Analysis.Interlevel.InterLevelCP.InterLevelCP a b)

module TypedGraph.GraphGrammar
graphGrammar :: GraphMorphism a b -> [AtomicConstraint (TypedGraphMorphism a b)] -> [(String, GraphRule a b)] -> [(String, SndOrderRule a b)] -> GraphGrammar a b
data GraphGrammar a b
initialGraph :: GraphGrammar a b -> GraphMorphism a b
constraints :: GraphGrammar a b -> [AtomicConstraint (TypedGraphMorphism a b)]
rules :: GraphGrammar a b -> [(String, GraphRule a b)]
sndOrderRules :: GraphGrammar a b -> [(String, SndOrderRule a b)]
typeGraph :: GraphGrammar a b -> Graph a b
instance GHC.Show.Show (TypedGraph.GraphGrammar.GraphGrammar a b)

module XML.GGXWriter

-- | Writes grammar, conflicts and dependencies (.cpx)
writeConfDepFile :: DPOConfig -> GraphGrammar a b -> String -> [(String, String)] -> String -> IO ()

-- | Writes the grammar and the conflicts (.cpx)
writeConflictsFile :: DPOConfig -> GraphGrammar a b -> String -> [(String, String)] -> String -> IO ()

-- | Writes the grammar and the dependencies (.cpx)
writeDependenciesFile :: DPOConfig -> GraphGrammar a b -> String -> [(String, String)] -> String -> IO ()

-- | Writes grammar, second order conflicts and dependencies (.ggx)
writeSndOderConfDepFile :: DPOConfig -> GraphGrammar a b -> String -> [(String, String)] -> String -> IO ()

-- | Writes the grammar and the second order conflicts (.ggx)
writeSndOderConflictsFile :: DPOConfig -> GraphGrammar a b -> String -> [(String, String)] -> String -> IO ()

-- | Writes the grammar and the second order dependencies (.ggx)
writeSndOderDependenciesFile :: DPOConfig -> GraphGrammar a b -> String -> [(String, String)] -> String -> IO ()

-- | Writes only the grammar (.ggx)
writeGrammarFile :: GraphGrammar a b -> String -> [(String, String)] -> String -> IO ()

module XML.GGXReader

-- | Reads the grammar in the XML, adds the needed minimal safety nacs to
--   second order, and returns the grammar and a log
readGrammar :: String -> Bool -> DPOConfig -> IO (GraphGrammar a b, [(String, Int)])
readGGName :: String -> IO String
readName :: String -> IO [String]

-- | Reads the names of node/edge types and NACs, which are necessary when
--   reexporting this grammar.
--   
--   To lookup the name of a node type, use <tt><a>I</a> ++ show
--   nodeId</tt> as key, where <tt>nodeId</tt> is the ID of the node in the
--   type graph. Lookup of edge types is analogous.
readNames :: String -> IO [(String, String)]
readTypeGraph :: String -> IO [ParsedTypeGraph]
readRules :: String -> IO [RuleWithNacs]
readGraphs :: String -> IO [(String, TypedGraph a b)]
readSequences :: GraphGrammar a b -> String -> IO [(String, [GraphRule a b])]
instantiateRule :: TypeGraph a b -> RuleWithNacs -> GraphRule a b
instantiateSpan :: TypedGraph a b -> TypedGraph a b -> [Mapping] -> (TypedGraphMorphism a b, TypedGraphMorphism a b)
minimalSafetyNacsWithLog :: DPOConfig -> GraphGrammar a b -> (GraphGrammar a b, [(String, Int)])
printMinimalSafetyNacsLog :: DPOConfig -> [(String, Int)] -> [String]

module Dot
data NamingContext
Ctx :: (NodeId -> String) -> (EdgeId -> String) -> NamingContext
[getNodeTypeName] :: NamingContext -> NodeId -> String
[getEdgeTypeName] :: NamingContext -> EdgeId -> String
printDigraph :: String -> [String] -> [Doc] -> [Doc] -> Doc

-- | Create a dotfile representation of the given state space, labeling
--   states with their IDs
printStateSpace :: StateSpace (TypedGraphMorphism a b) -> Doc

-- | Create a dotfile representation of the given typed graph, labeling
--   nodes with their types
printTypedGraph :: NamingContext -> String -> TypedGraph a b -> Doc
nodeId :: NodeId -> Doc
edgeId :: EdgeId -> Doc
